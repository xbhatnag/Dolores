import argparse
import dataclasses
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
from email.mime.audio import MIMEAudio
import json
import logging
from datetime import datetime, timedelta, timezone
from queue import Queue
from zoneinfo import ZoneInfo

from dateutil.parser import parse as parse_date
from flask import Flask, Response
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication

from factoid import spawn_factoid
from journalist import spawn_journalist
from script import Script
from trendy import spawn_trendy

queue: Queue = Queue()
app = Flask(__name__)


@app.route("/next")
def get_next_script():
    logging.info("Narrator is waiting for next script...")
    script: Script = queue.get()

    # 1. Create a MIMEMultipart object
    msg = MIMEMultipart(
        "mixed"
    )  # 'mixed' is a common subtype for general multipart responses

    # 2. Add a JSON part
    json_data = {"title": script.title, "audio_text": script.audio_text}
    # MIMEText expects a string, so convert JSON dict to string
    json_part = MIMEText(json.dumps(json_data), "json")
    json_part.add_header("Content-Disposition", "attachment", filename="metadata.json")
    msg.attach(json_part)

    # 4. Add a dummy PNG image part
    # Create a simple red square image in memory
    image_part = MIMEImage(script.image_data, "png")
    image_part.add_header(
        "Content-Disposition", "attachment", filename="screenshot.png"
    )
    msg.attach(image_part)

    # 5. Add a dummy MP3 audio part
    audio_part = MIMEAudio(script.audio_data, _subtype="mpeg")
    audio_part.add_header("Content-Disposition", "attachment", filename="narrator.mp3")
    msg.attach(audio_part)

    # 6. Get the raw string representation of the multipart message
    # The as_string() method includes the Content-Type header with the boundary.
    response_body = msg.as_string()

    # Remove the email-specific 'From:', 'To:', 'Subject:' headers that as_string() adds
    # We only want the HTTP headers to be handled by Flask's Response object.
    # This assumes the first three lines are always these headers.
    response_body = response_body.split("\n", 3)[
        3
    ]  # Split by newline, take part after 3rd newline

    # 7. Create Flask Response
    # Set the mimetype to the Content-Type generated by MIMEMultipart, which includes the boundary
    response = Response(response_body, mimetype=msg.get("Content-Type"))

    return response


def now() -> datetime:
    # We know we are in west coast.
    return datetime.now(tz=ZoneInfo("America/Los_Angeles"))


def main():
    global queue

    parser = argparse.ArgumentParser(description="Director")
    parser.add_argument(
        "--after", "-a", type=str, help="Only get articles after this date + time"
    )
    parser.add_argument(
        "--port", "-p", type=int, default=8080, help="Port number for HTTP server"
    )
    args = parser.parse_args()

    logging.basicConfig(format="%(levelname)s: %(message)s")
    logging.getLogger().setLevel(logging.INFO)
    logging.info("Welcome to Jockey! I'm the Director.")

    after = now() - timedelta(days=3)
    if args.after:
        after = parse_date(args.after)

    spawn_journalist(queue, after)
    # spawn_factoid(queue)

    # spawn_trendy(queue)

    # Serve HTTP server
    app.run(host="127.0.0.1", port=args.port)


if __name__ == "__main__":
    main()
